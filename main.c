#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <setjmp.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

typedef struct __jmp_buf_tag sigjmp_buf[1];



int ll = 0; /* счетчик прерывания */

sigjmp_buf obl; /* область памяти для запоминания состояния процесса */

/* Подпрограмма обработки прерывания */
void po13() {
    ll++;
    signal(SIGINT, po13);
    if (ll > 9) /* не больше 9ти прерываний */
    {
        printf("good bye\n");
        _exit(1);
    }
    printf(" П P E P Ы В А Н И E !!! \n");
    siglongjmp(obl, 1); /* возвращение на последний
setjmp */
}


/* Подпрограмма сравнения строк */
//int cmpstr(char *vv, char *nn) {
////    char vv[];
////    char nn[];
//    int i, m1, m2;
//    for (m1 = 0; vv[m1] != '\0'; m1++);
//    for (m2 = 0; vv[m2] != '\0'; m2++);
//    if (m1 != m2) return (0); /* длины строк vv и nn разные */
//    for (i = 0; i < m1; i++) {
//        if (vv[i] != nn[i]) return (i + 1); /* строки равны по длине, но отличаются (i + 1) символом */
//        return (-1); /* строки одинаковы */
//    }
//}


int main() {

    char n1[100];
    char n2[100]; /* символьные массивы для считывания информации из канала */
    int vv; /* флаг завершения работы программы */
    int gg = 0;
    int g[2]; /* дескрипторы межпроцессного канала */
    signal(SIGINT,
           po13); /* уведомление о том, что в случае прихода сигнала прерывания SIGINT, управление передается процедуре ро13 */
    sigsetjmp (obl, 1); /* запоминание текущего состояния процесса */
    vv = 0;
    do {
        sigsetjmp(obl, 1);
        pipe(g); /* создание межпроцессного канала */
        if (fork() == 0) /* распараллеливание процесса */
        { /* процесс-потомок */
            close(1); /* закрытие стандартного вывода */
            close(g[0]); /* закрытие межпроцессного канала на
чтение */
            dup2(g[1], 1); /* дублирование дескриптора
межпроцессного канала на стандартный вывод */
            close(g[1]); /* удалить копию */
            execl("/bin/ps", "ps", "ax", (char *)0); /* вывод всех активных процессов в системе в межпроцессный канал
*/
        } else {


            int *s;
            /* процесс-родитель */
            wait(s); /* ожидание окончания процесса-потомка */
            sigsetjmp(obl, 1);
            close(g[1]);
            read(g[0], obl, 80); /* считывание 1-ой записи из меж-
процессного канала */
            read(g[0], n1, 80); /* считывание 2-й записи */
            int rr = strcmp(obl, n1); /* сравнение двух строк */
            sigsetjmp(obl, 1);
            while (rr != -1) {
                if (rr == 4)
                    break; /* процесс управляется пользовательским терминалом */
                int m = atoi(n1); /* определение первого целого
числа из строки n1 */
                if (m == 0) vv = 1;
                if ((gg == 0) && (m != 0))
                    printf("%d\n",
                           gg);
                if (gg != m) printf("%d\n", m);
                gg = m;
                read(g[0], obl, 80);
                rr = strcmp(obl, n1);
                strcpy(n1, obl);
                sleep(1); /* ожидание 1 сек. */
            }

        }
    } while (vv != 1);
    sigsetjmp(obl, 1);
    printf("good bye !!!\n");
}

